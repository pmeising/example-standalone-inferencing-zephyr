/* Generated by Edge Impulse
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// Generated on: 05.03.2024 15:58:45

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#elif defined __ICCARM__
#define ALIGN(x) __attribute__((aligned(x)))
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 1584;
#else
constexpr int kTensorArenaSize = 560;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};

enum used_operators_e {
  OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};

struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

namespace g0 {
const TfArray<2, int> tensor_dimension0 = { 2, { 1,39 } };
const ALIGN(16) float tensor_data1[10] = { -0.037633731961250305, -0.071167439222335815, 0, -0.00013530610885936767, 0, 0, -0.010339257307350636, 0.013733904808759689, 0.067568778991699219, 0.043216664344072342, };
const TfArray<1, int> tensor_dimension1 = { 1, { 10 } };
const ALIGN(16) float tensor_data2[20] = { 0, 0, -0.0066573172807693481, -0.0057680965401232243, -0.0092409094795584679, 0.059803035110235214, -0.036122862249612808, 0.11126857995986938, 0.057350538671016693, 0.0081910993903875351, -0.0087500428780913353, 0.079079218208789825, -0.086959786713123322, -0.053411763161420822, -0.026477990671992302, -0.031915061175823212, 0.037894874811172485, 0.065054140985012054, 0, 0, };
const TfArray<1, int> tensor_dimension2 = { 1, { 20 } };
const ALIGN(8) float tensor_data3[3] = { 0.032457981258630753, -0.061431530863046646, 0.034519325941801071, };
const TfArray<1, int> tensor_dimension3 = { 1, { 3 } };
const ALIGN(16) float tensor_data4[20*39] = { 
  -0.0013192892074584961, -0.044039040803909302, -0.069627821445465088, 0.26001393795013428, 0.089061975479125977, 0.15267705917358398, 0.09004780650138855, -0.20172545313835144, 0.10422086715698242, -0.25133448839187622, -0.0098548233509063721, 0.11228027939796448, -0.27787047624588013, -0.20417821407318115, -0.068315684795379639, 0.27663165330886841, 0.078157484531402588, 0.22731858491897583, -0.15213684737682343, -0.15126363933086395, 0.27022862434387207, -0.081613317131996155, 0.26134604215621948, 0.055435359477996826, -0.28826260566711426, 0.19950282573699951, -0.15309947729110718, -0.15434029698371887, -0.21764516830444336, -0.28208708763122559, 0.074981063604354858, 0.096461385488510132, 0.18870669603347778, -0.25964847207069397, -0.29576432704925537, 0.13501471281051636, -0.19551676511764526, 0.22598057985305786, -0.029596507549285889, 
  -0.30873838067054749, -0.021184921264648438, 0.25657212734222412, 0.039397656917572021, -0.09235776960849762, 0.052269130945205688, 0.09853169322013855, 0.094210952520370483, 0.13782510161399841, 0.28930234909057617, -0.20153316855430603, 0.13103783130645752, 0.041992813348770142, 0.057746410369873047, 0.19240546226501465, -0.16865196824073792, 0.24439781904220581, 0.15468442440032959, 0.3178824782371521, -0.18789750337600708, -0.052646547555923462, -0.031061559915542603, 0.25848013162612915, -0.059618204832077026, 0.15976807475090027, 0.15219295024871826, -0.05622592568397522, 0.22718971967697144, -0.075883716344833374, -0.23083445429801941, -0.049289047718048096, 0.29307246208190918, 0.27104336023330688, 0.30389958620071411, 0.21434664726257324, -0.098953142762184143, -0.25012636184692383, -0.028933078050613403, 0.082270830869674683, 
  0.23851083219051361, -0.059829860925674438, -0.32634076476097107, -0.21861712634563446, 0.18651224672794342, -0.17911221086978912, 0.17628644406795502, 0.25029867887496948, 0.28633999824523926, -0.040317237377166748, -0.2483983039855957, 0.040415752679109573, -0.23965771496295929, 0.16075390577316284, -0.33895489573478699, 0.12391238659620285, 0.10773070901632309, 0.17810314893722534, -0.012085813097655773, 0.11823254823684692, 0.29683929681777954, -0.31095537543296814, 0.16041281819343567, -0.26244604587554932, 0.022254042327404022, -0.098976157605648041, 0.32794532179832458, 0.20134323835372925, -0.22356872260570526, -0.23963293433189392, -0.14361464977264404, 0.19812768697738647, 0.15206636488437653, -0.23329804837703705, -0.067385181784629822, -0.10985666513442993, -0.27482518553733826, -0.027428712695837021, 0.1759791225194931, 
  -0.26836735010147095, 0.17017766833305359, -0.16491019725799561, 0.18027336895465851, -0.021917691454291344, 0.17587730288505554, -0.038509875535964966, 0.29785937070846558, 0.14915800094604492, -0.27397900819778442, 0.24892687797546387, 0.24610459804534912, 0.14534126222133636, 0.18658614158630371, 0.12687677145004272, -0.071487434208393097, -0.25000137090682983, -0.14553959667682648, 0.097012840211391449, 0.19098402559757233, -0.21238216757774353, 0.12150838971138, -0.2102510929107666, -0.12348584830760956, 0.18495355546474457, 0.15387266874313354, -0.2320384681224823, 0.18661826848983765, 0.25469428300857544, 0.19999964535236359, -0.13932543992996216, 0.12307668477296829, 0.25608232617378235, -0.14700789749622345, 0.18383045494556427, 0.03340575098991394, 0.30169039964675903, -0.30916944146156311, 0.052811574190855026, 
  0.23679700493812561, 0.074156098067760468, 0.067682728171348572, -0.20673154294490814, -0.23882170021533966, -0.24231281876564026, 0.25745615363121033, -0.08283841609954834, -0.15406063199043274, 0.17961655557155609, -0.099218025803565979, 0.050276082009077072, -0.20459514856338501, -0.15213392674922943, -0.13747160136699677, 0.20754347741603851, 0.17323900759220123, 0.24387885630130768, -0.032911404967308044, -0.080014131963253021, -0.040783029049634933, 0.28440374135971069, -0.069647282361984253, -0.056152019649744034, -0.10613738000392914, 0.0099896742030978203, 0.20658266544342041, 0.19764512777328491, -0.29117554426193237, -0.25793522596359253, 0.17561407387256622, -0.21378745138645172, 0.27004733681678772, -0.2361934632062912, -0.10993298888206482, -0.16355377435684204, -0.1086650937795639, -0.30039790272712708, 0.057847153395414352, 
  -0.12358152866363525, 0.2582344114780426, 0.18097312748432159, 0.014067919924855232, -0.18919038772583008, -0.2071637362241745, 0.075707294046878815, 0.35710471868515015, -0.078367210924625397, 0.11057978868484497, -0.25571531057357788, -0.077022619545459747, -0.27365982532501221, 0.13326360285282135, 0.26699551939964294, 0.16313979029655457, -0.27030810713768005, 0.066992834210395813, -0.053211234509944916, 0.0696430504322052, -0.19973072409629822, -0.2122495025396347, 0.013798752799630165, -0.11363554000854492, 0.27508360147476196, -0.032861541956663132, 0.060124639421701431, -0.1367390900850296, 0.056514274328947067, 0.34886020421981812, -0.049155257642269135, 0.010436290875077248, 0.28582653403282166, -0.15318940579891205, 0.11153900623321533, -0.25407588481903076, 0.25179922580718994, -0.14276596903800964, 0.16609016060829163, 
  0.11570737510919571, -0.080179087817668915, -0.13373258709907532, -0.20771592855453491, -0.19949664175510406, -0.34169024229049683, -0.13321205973625183, 0.19401571154594421, -0.1440313458442688, -0.0067915529944002628, -0.045367725193500519, -0.055823411792516708, -0.029924670234322548, 0.1731734573841095, 0.14165531098842621, -0.072715245187282562, -0.16364282369613647, -0.14385756850242615, 0.27964946627616882, 0.21599532663822174, -0.17938721179962158, 0.029479250311851501, -0.17440271377563477, 0.17268043756484985, -0.15601970255374908, -0.060412883758544922, 0.29534158110618591, -0.24291454255580902, 0.21248646080493927, 0.039623569697141647, 0.16440552473068237, -0.32540223002433777, -0.02851034514605999, -0.072870343923568726, -0.27954217791557312, 0.14950661361217499, -0.32062482833862305, 0.09717385470867157, -0.28870022296905518, 
  0.19212377071380615, -0.28543797135353088, 0.20515260100364685, 0.32872927188873291, 0.15640653669834137, 0.17807681858539581, 0.17800223827362061, 0.21674764156341553, -0.012207896448671818, 0.35040691494941711, 0.013664832338690758, 0.38288614153862, -0.031575750559568405, 0.11096776276826859, 0.014030443504452705, -0.13160571455955505, -0.060548175126314163, -0.20455670356750488, -0.12224945425987244, 0.38335737586021423, 0.35311225056648254, -0.1064944714307785, -0.078369736671447754, 0.082901254296302795, 0.019375666975975037, 0.3992670476436615, -0.12057055532932281, -0.0017838913481682539, -0.099718838930130005, 0.024602718651294708, 0.05820886418223381, 0.38308167457580566, 0.1572863906621933, -0.19019992649555206, -0.029549583792686462, -0.20776811242103577, 0.027474621310830116, 0.17468637228012085, 0.2983241081237793, 
  0.13835768401622772, 0.3360937237739563, 0.32248440384864807, -0.031108353286981583, -0.36699587106704712, 0.23905649781227112, 0.0099166138097643852, -0.14234863221645355, 0.0188636165112257, -0.0079099256545305252, 0.060140609741210938, 0.23067478835582733, 0.22113727033138275, -0.12857434153556824, 0.27784815430641174, 0.039362069219350815, 0.14247913658618927, -0.17573879659175873, 0.35787370800971985, 0.10980653017759323, 0.33702248334884644, 0.26384556293487549, 0.32678008079528809, 0.17440235614776611, 0.24085205793380737, 0.25215435028076172, 0.19483798742294312, -0.1163364052772522, 0.49480414390563965, -0.2445472925901413, 0.17502185702323914, -0.25538256764411926, -0.0033238579053431749, 0.035298813134431839, -0.22012953460216522, -0.049158994108438492, -0.23852942883968353, 0.30747035145759583, -0.17171461880207062, 
  -0.25611633062362671, 0.15011270344257355, -0.26042309403419495, -0.012346966192126274, -0.17556826770305634, 0.19599525630474091, -0.28010457754135132, 0.0062594851478934288, -0.16502209007740021, -0.31030881404876709, -0.26198750734329224, -0.20901325345039368, -0.30929771065711975, -0.073970206081867218, -0.21018466353416443, 0.25568684935569763, -0.026171004399657249, 0.19320142269134521, 0.23120041191577911, -0.1936514675617218, -0.057620033621788025, 0.20809142291545868, 0.069930829107761383, 0.3031940758228302, 0.32595232129096985, 0.22162365913391113, 0.024982903152704239, 0.10178715735673904, -0.00056400167522951961, 0.15133707225322723, -0.13110001385211945, -0.081519477069377899, -0.2225327342748642, -0.0014532468048855662, 0.23025909066200256, 0.1047283262014389, 0.22217878699302673, 0.24741595983505249, -0.037600032985210419, 
  0.28668582439422607, 0.080520808696746826, 0.14943702518939972, -0.31147646903991699, -0.24204158782958984, -0.1384844183921814, 0.17221376299858093, 0.03927651047706604, -0.031268224120140076, 0.092933788895606995, -0.25176626443862915, 0.083328388631343842, 0.072252370417118073, -0.26282709836959839, 0.15773285925388336, -0.18885546922683716, -0.013720202259719372, -0.0095264045521616936, 0.10017463564872742, 0.056574884802103043, -0.28078582882881165, 0.13541015982627869, -0.30201584100723267, 0.23508718609809875, 0.24915921688079834, -0.068678438663482666, -0.16753277182579041, -0.107755146920681, 0.21705149114131927, 0.20545648038387299, -0.29800483584403992, -0.26182535290718079, -0.26127037405967712, -0.080278337001800537, 0.30428799986839294, 0.26685655117034912, -0.10143644362688065, -0.25876596570014954, -0.2593512237071991, 
  -0.072895936667919159, 0.12422538548707962, 0.39400032162666321, -0.057101525366306305, -0.32718262076377869, -0.23054848611354828, 0.36779049038887024, -0.072481252253055573, 0.28500857949256897, -0.022782662883400917, 0.31792497634887695, 0.33535727858543396, 0.24723929166793823, 0.27307450771331787, 0.087876178324222565, 0.29889902472496033, -0.11064311861991882, -0.1395220160484314, 0.33721956610679626, 0.059820059686899185, -0.016502659767866135, -0.010367650538682938, 0.35582378506660461, 0.063892826437950134, 0.14949382841587067, 0.18337862193584442, 0.17322227358818054, 0.063884936273097992, 0.51842844486236572, 0.17515154182910919, -0.0100442785769701, -0.012907741591334343, 0.065697081387042999, -0.078950636088848114, 0.13386861979961395, -0.02044457383453846, -0.17169828712940216, 0.13048043847084045, 0.12974841892719269, 
  -0.11302762478590012, -0.3274436891078949, -0.11849437654018402, -0.1437705010175705, 0.28979465365409851, -0.33375361561775208, -0.25298941135406494, -0.36922526359558105, -0.31799861788749695, 0.091945603489875793, -0.12914241850376129, -0.34698963165283203, 0.022902090102434158, 0.18036733567714691, -0.3244667649269104, 0.067789353430271149, 0.01439464557915926, -0.078354902565479279, 0.199416384100914, -0.14849938452243805, 0.082468658685684204, 0.10950303822755814, -0.26118388772010803, 0.13455106317996979, 0.095176070928573608, -0.16954027116298676, 0.050758209079504013, -0.066949844360351562, 0.054720703512430191, -0.13726958632469177, -0.13540059328079224, 0.011406701058149338, -0.36853638291358948, 0.22465910017490387, 0.13653834164142609, 0.13635699450969696, 0.19824530184268951, -0.2692408561706543, -0.32442060112953186, 
  0.098762437701225281, -0.33304592967033386, -0.32313129305839539, -0.04430047795176506, 0.3464503288269043, 0.2609773576259613, -0.31312856078147888, 0.2528289258480072, -0.0881524458527565, 0.031648173928260803, 0.019675439223647118, 0.045938916504383087, 0.24065189063549042, 0.092107526957988739, -0.31402373313903809, -0.4349682629108429, -0.33797344565391541, -0.067866973578929901, -0.30223757028579712, -0.16027580201625824, -0.28773751854896545, -0.29911530017852783, -0.06267402321100235, -0.14828117191791534, -0.17990615963935852, -0.36656132340431213, -0.19348853826522827, 0.35927757620811462, -0.28339079022407532, 0.0046520335599780083, 0.090064018964767456, -0.3519841730594635, -0.27839869260787964, -0.34752902388572693, -0.084386244416236877, 0.036285065114498138, 0.10451465845108032, -0.063605651259422302, 0.21782572567462921, 
  0.26399394869804382, -0.25136032700538635, -0.1788608729839325, 0.037331387400627136, 0.032426062971353531, -0.21098516881465912, -0.16297368705272675, 0.085467249155044556, 0.12654125690460205, 0.082233458757400513, 0.2820943295955658, -0.33654877543449402, -0.29405418038368225, 0.29587942361831665, -0.26307639479637146, -0.12771248817443848, -0.30483776330947876, 0.080880105495452881, 0.15720976889133453, -0.27093547582626343, 0.24447159469127655, 0.28510335087776184, -0.18252956867218018, 0.20711268484592438, -0.31840026378631592, -0.20759028196334839, -0.068994127213954926, -0.25339657068252563, 0.21554549038410187, -0.11551928520202637, 0.31304338574409485, -0.19635112583637238, -0.16881392896175385, 0.16942436993122101, -0.072903215885162354, -0.23410432040691376, -0.27800130844116211, 0.047433804720640182, 0.22693678736686707, 
  0.025882251560688019, 0.25746890902519226, -0.29767236113548279, -0.31398960947990417, -0.23720996081829071, 0.052870545536279678, -0.076093487441539764, 0.016273915767669678, 0.081379339098930359, 0.072097659111022949, -0.048821184784173965, 0.093533709645271301, -0.20528359711170197, 0.15453499555587769, -0.050777360796928406, 0.10458606481552124, 0.046688079833984375, 0.16783486306667328, 0.075521811842918396, 0.15249079465866089, -0.32503637671470642, 0.22752594947814941, -0.29092225432395935, 0.10408584028482437, 0.03716697171330452, -0.036654599010944366, -0.11843398213386536, -0.046940386295318604, -0.22950123250484467, -0.18603850901126862, 0.10686080157756805, -0.14164890348911285, -0.14515754580497742, 0.13697174191474915, -0.05274311825633049, 0.039523407816886902, -0.025876522064208984, -0.32192006707191467, 0.054493382573127747, 
  -0.017508657649159431, -0.20854978263378143, -0.11574199795722961, -0.020382711663842201, 0.16543479263782501, -0.041580658406019211, -0.06098797544836998, -0.18349933624267578, 0.147661492228508, -0.24632932245731354, -0.24587585031986237, -0.070620663464069366, 0.10267491638660431, 0.15062384307384491, -0.013074502348899841, 0.19940075278282166, -0.25774118304252625, -0.23361305892467499, 0.1750713586807251, -0.063035741448402405, -0.2277970165014267, -0.14515683054924011, 0.15098811686038971, -0.099534250795841217, 0.16694174706935883, -0.066826649010181427, -0.068712607026100159, 0.22681029140949249, -0.041553739458322525, 0.22231557965278625, 0.012707783840596676, 0.035093005746603012, 0.28394287824630737, -0.15763530135154724, -0.066525898873806, -0.14045651257038116, 0.12247840315103531, -0.23661221563816071, -0.1171213835477829, 
  -0.084650687873363495, 0.18112541735172272, 0.42336353659629822, 0.26544421911239624, 0.16922640800476074, -0.042868353426456451, -0.067693285644054413, 0.3167421817779541, 0.16553927958011627, 0.013397843576967716, -0.061762720346450806, 0.35568982362747192, -0.062901049852371216, 0.21750688552856445, 0.022319762036204338, 0.09526999294757843, -0.19624365866184235, 0.079706519842147827, 0.34715023636817932, -0.11898358166217804, 0.22599612176418304, -0.074224524199962616, -0.17802765965461731, 0.36685892939567566, -0.11396146565675735, -0.18378236889839172, -0.17878833413124084, 0.0040788957849144936, 0.19958508014678955, -0.13623908162117004, 0.0094516780227422714, -0.18605555593967438, 0.062869660556316376, 0.1285378634929657, 0.07947724312543869, 0.36283555626869202, 0.34779873490333557, -0.11932036280632019, 0.27070999145507812, 
  -0.26661062240600586, -0.08108915388584137, 0.16836532950401306, -0.30927538871765137, 0.15289822220802307, 0.026811212301254272, -0.20620685815811157, -0.029894798994064331, -0.0090014338493347168, -0.11141519248485565, -0.29277518391609192, -0.12127754092216492, -0.27076897025108337, -0.22425833344459534, -0.23647359013557434, -0.1653091162443161, 0.020051777362823486, -0.18728817999362946, -0.17330870032310486, 0.12142953276634216, -0.15760035812854767, 0.26248288154602051, -0.17257151007652283, 0.24910187721252441, -0.13743537664413452, -0.27617034316062927, -0.012506753206253052, -0.090247452259063721, -0.28282752633094788, -0.21925945580005646, 0.14626339077949524, -0.13725222647190094, -0.20096468925476074, -0.28527733683586121, 0.31257271766662598, 0.2502245306968689, 0.087845116853713989, -0.21333695948123932, -0.24438035488128662, 
  -0.010288327932357788, 0.23818576335906982, 0.016662299633026123, -0.15525594353675842, -0.054137378931045532, -0.10412392020225525, 0.094403743743896484, -0.041926741600036621, 0.22788453102111816, 0.21502029895782471, -0.25614559650421143, 0.25070565938949585, 0.21814626455307007, -0.0036417245864868164, -0.0051015913486480713, -0.12987016141414642, -0.0087834000587463379, -0.26534461975097656, -0.16865508258342743, 0.085449755191802979, -0.11979356408119202, -0.29055896401405334, 0.24866819381713867, -0.2487984299659729, -0.021129429340362549, 0.0083251595497131348, -0.20508487522602081, -0.13340795040130615, 0.11183822154998779, 0.25093108415603638, -0.22106237709522247, 0.046615332365036011, 0.26770472526550293, -0.19769901037216187, 0.027333617210388184, 0.10976326465606689, -0.28933721780776978, 0.068516016006469727, 0.019320130348205566, 
};
const TfArray<2, int> tensor_dimension4 = { 2, { 20,39 } };
const ALIGN(16) float tensor_data5[10*20] = { 
  0.155190110206604, -0.29567396640777588, -0.2714935839176178, 0.034827355295419693, 0.37001296877861023, 0.049668837338685989, 0.42219865322113037, -0.40773829817771912, -0.040222987532615662, -0.20351500809192657, 0.077423244714736938, 0.05618547648191452, 0.2329210638999939, 0.42564898729324341, 0.2058994323015213, -0.30957514047622681, 0.013250671327114105, -0.11229133605957031, -0.26989120244979858, 0.094074904918670654, 
  -0.21513541042804718, -0.43652644753456116, 0.28639724850654602, 0.23964527249336243, 0.27173230051994324, -0.14864620566368103, -0.1738780289888382, -0.35124450922012329, -0.30366727709770203, -0.23426839709281921, -0.21241985261440277, -0.18893882632255554, 0.24456372857093811, 0.096798166632652283, 0.28767994046211243, 0.34278443455696106, -0.18454839289188385, 0.11020802706480026, -0.1693665087223053, -0.11774033308029175, 
  -0.086540102958679199, -0.36983108520507812, -0.011426568031311035, 0.40303337574005127, -0.18503651022911072, -0.22609998285770416, -0.13627669215202332, 0.078819572925567627, -0.15676471590995789, -0.043710947036743164, 0.12338340282440186, 0.19389015436172485, -0.081969767808914185, -0.33017858862876892, -0.050489902496337891, -0.26666605472564697, 0.32243669033050537, -0.3727266788482666, -0.38322222232818604, -0.30915829539299011, 
  0.22499942779541016, 0.051235824823379517, 0.38460239768028259, 0.027167277410626411, -0.19805635511875153, 0.29646927118301392, -0.19965142011642456, -0.15893493592739105, -0.063325084745883942, 0.28969678282737732, 0.37559360265731812, 0.19666635990142822, -0.28328722715377808, -0.34876528382301331, -4.5455690269591287e-05, -0.18276317417621613, -0.10420431941747665, -0.24189414083957672, 0.40465575456619263, 0.32163810729980469, 
  -0.17334240674972534, 0.22864800691604614, -0.36935180425643921, -0.16372278332710266, -0.32421711087226868, 0.26705628633499146, -0.13781583309173584, 0.10276287794113159, -0.35277539491653442, 0.23458927869796753, 0.34554034471511841, 0.21861153841018677, -0.077009856700897217, 0.18902230262756348, 0.094670414924621582, -0.36372420191764832, -0.18604752421379089, 0.38466089963912964, 0.27800458669662476, 0.22064423561096191, 
  -0.33576247096061707, 0.26865863800048828, -0.2659904956817627, 0.19467127323150635, -0.11647129058837891, -0.44642287492752075, -0.025772631168365479, 0.29864662885665894, -0.44512087106704712, -0.17979496717453003, 0.29691082239151001, 0.22912448644638062, -0.19458532333374023, 0.23980724811553955, -0.091879725456237793, -0.25903475284576416, -0.14094427227973938, 0.23669981956481934, -0.25955837965011597, 0.015761494636535645, 
  0.35197710990905762, 0.18086844682693481, -0.23768751323223114, -0.30164176225662231, 0.29447969794273376, 0.28912600874900818, 0.031243780627846718, -0.13716776669025421, -0.11426122486591339, 0.00096109649166464806, 0.23713609576225281, 0.1444268673658371, -0.28603288531303406, -0.1639530211687088, 0.024991240352392197, -0.077044419944286346, 0.21956117451190948, -0.077691942453384399, -0.061746180057525635, -0.13303959369659424, 
  -0.057526230812072754, 0.34791058301925659, 0.1967138946056366, 0.24965286254882812, 0.0018082729075103998, 0.31932184100151062, 0.35110649466514587, -0.41740086674690247, 0.47428286075592041, -0.10604450851678848, -0.23708005249500275, 0.43610182404518127, 0.23783203959465027, -0.10816790163516998, -0.37685948610305786, 0.15704555809497833, 0.29562166333198547, -0.052190706133842468, 0.051685571670532227, 0.32153928279876709, 
  0.23891192674636841, 0.15565967559814453, 0.22995653748512268, 0.15996217727661133, 0.36227571964263916, 0.12046071141958237, -0.39991128444671631, -0.043349061161279678, -0.088538140058517456, 0.055738545954227448, 0.36313968896865845, 0.090702645480632782, -0.037289686501026154, -0.42908632755279541, -0.081650078296661377, 0.32205647230148315, -0.39641472697257996, 0.22383223474025726, -0.18146216869354248, -0.12500813603401184, 
  0.16866344213485718, -0.27388951182365417, -0.086125247180461884, -0.014092941768467426, 0.2508598268032074, 0.37790673971176147, -0.09931076318025589, 0.023510459810495377, 0.25190973281860352, -0.36516553163528442, -0.22932247817516327, 0.17279726266860962, -0.29003125429153442, -0.22001153230667114, 0.19573788344860077, -0.071573823690414429, -0.077772513031959534, 0.35632675886154175, 0.010248482227325439, 0.29526698589324951, 
};
const TfArray<2, int> tensor_dimension5 = { 2, { 10,20 } };
const ALIGN(16) float tensor_data6[3*10] = { 
  0.36154809594154358, 0.058345653116703033, 0.57208549976348877, -0.54104053974151611, -0.23708584904670715, 0.29448860883712769, 0.46496602892875671, -0.54619473218917847, -0.72100150585174561, 0.4575096070766449, 
  0.40439572930335999, 0.40628260374069214, -0.12294971942901611, -0.40380486845970154, -0.62878239154815674, 0.055912435054779053, 0.20246706902980804, -0.51423406600952148, 0.091337636113166809, -0.10658571124076843, 
  -0.53235828876495361, -0.14718019962310791, 0.66433978080749512, 0.015684580430388451, -0.57159680128097534, -0.5093843936920166, -0.53934115171432495, -0.28174754977226257, 0.6318088173866272, 0.18740011751651764, 
};
const TfArray<2, int> tensor_dimension6 = { 2, { 3,10 } };
const TfArray<2, int> tensor_dimension7 = { 2, { 1,20 } };
const TfArray<2, int> tensor_dimension8 = { 2, { 1,10 } };
const TfArray<2, int> tensor_dimension9 = { 2, { 1,3 } };
const TfArray<2, int> tensor_dimension10 = { 2, { 1,3 } };
const TfLiteFullyConnectedParams opdata0 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs0 = { 3, { 0,4,2 } };
const TfArray<1, int> outputs0 = { 1, { 7 } };
const TfLiteFullyConnectedParams opdata1 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs1 = { 3, { 7,5,1 } };
const TfArray<1, int> outputs1 = { 1, { 8 } };
const TfLiteFullyConnectedParams opdata2 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs2 = { 3, { 8,6,3 } };
const TfArray<1, int> outputs2 = { 1, { 9 } };
const TfLiteSoftmaxParams opdata3 = { 1 };
const TfArray<1, int> inputs3 = { 1, { 9 } };
const TfArray<1, int> outputs3 = { 1, { 10 } };
};

TensorInfo_t tensorData[] = {
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension0, 156, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data1, (TfLiteIntArray*)&g0::tensor_dimension1, 40, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data2, (TfLiteIntArray*)&g0::tensor_dimension2, 80, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data3, (TfLiteIntArray*)&g0::tensor_dimension3, 12, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data4, (TfLiteIntArray*)&g0::tensor_dimension4, 3120, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data5, (TfLiteIntArray*)&g0::tensor_dimension5, 800, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data6, (TfLiteIntArray*)&g0::tensor_dimension6, 120, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 160), (TfLiteIntArray*)&g0::tensor_dimension7, 80, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension8, 40, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 48), (TfLiteIntArray*)&g0::tensor_dimension9, 12, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension10, 12, },
};

#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[4] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[4] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_SOFTMAX, };


// Indices into tflTensors and tflNodes for subgraphs
const size_t tflTensors_subgraph_index[] = {0, 11, };
const size_t tflNodes_subgraph_index[] = {0, 4, };

// Input/output tensors
static const int in_tensor_indices[] = {
  0, 
};

static const int out_tensor_indices[] = {
  10, 
};


size_t current_subgraph_index = 0;

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = kTfLiteFloat32;
  tensor->is_variable = false;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization.type = kTfLiteNoQuantization;

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = kTfLiteFloat32;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}

typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;

static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
 
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  }

  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }

  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }
 
  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }

  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }

  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }

};


} // namespace

TfLiteStatus tflite_learn_10_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  
  // Set microcontext as the context ptr
  ctx.impl_ = static_cast<void*>(&micro_context_);
  // Setup tflitecontext functions
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;

  ctx.tensors_size = 11;
  for (size_t i = 0; i < 11; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }

  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }

  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].init) {
        tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
      }
    }
  }
  current_subgraph_index = 0;

  for(size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].prepare) {
        ResetTensors();
        TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
        if (status != kTfLiteOk) {
          return status;
        }
      }
    }
  }
  current_subgraph_index = 0;

  return kTfLiteOk;
}

TfLiteStatus tflite_learn_10_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(in_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_10_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(out_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_10_invoke() {
  for (size_t i = 0; i < 4; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_10_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
